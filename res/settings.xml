
<mygl-generator>
  <platform use-khr="false">core</platform>
  <extensions>
    <extension>GL_ARB_bindless_texture</extension>
    <extension>GL_ARB_direct_state_access</extension>
    <extension>GL_ARB_compute_variable_group_size</extension>
    <extension>GL_ARB_vertex_attrib_binding</extension>
    <extension>GL_ARB_gpu_shader_int64</extension>
    <extension>GL_EXT_texture_filter_anisotropic</extension>
    <extension>GL_KHR_debug</extension>
    <extension>GL_NVX_gpu_memory_info</extension>
    <extension>GL_NV_bindless_multi_draw_indirect</extension>
    <extension>GL_NV_bindless_multi_draw_indirect_count</extension>
    <extension>GL_NV_command_list</extension>
    <extension>GL_NV_path_rendering</extension>
    <extension>GL_NV_shader_buffer_load</extension>
    <extension>GL_NV_shader_buffer_store</extension>
    <extension>GL_NV_uniform_buffer_unified_memory</extension>
    <extension>GL_NV_vertex_buffer_unified_memory</extension>
    <extension>GL_NV_gpu_program5</extension>
    <extension>GL_NV_gpu_shader5</extension>
    <extension>GL_NV_compute_program5</extension>
    <extension>GL_NV_gpu_program5_mem_extended</extension>
  </extensions>
  <commands>
    <command>glEnableClientState</command>
    <command>glDisableClientState</command>
    <command>glDrawTextureNV</command>
  </commands>
  <rules namespace="mygl">
    <handle-rule typename="buffer" type="uint32_t">
      <match param-expression="(readB|writeB|b)uffer(s|)" command-expression="((?!Framebuffer).)*"/>
    </handle-rule>

    <handle-rule typename="shader_program" type="uint32_t">
      <match param-expression="program(s|)"/>
      <match enable-return="true" command-expression="glCreate(Shader|)Program.*"/>
    </handle-rule>

    <handle-rule typename="shader" type="uint32_t">
      <match param-expression="shader(s|)"/>
      <match enable-return="true" command-expression="glCreateShader"/>
    </handle-rule>

    <handle-rule typename="query" type="uint32_t">
      <match command-expression="gl.*Quer(y|ies).*" param-expression="id(s|)"/>
    </handle-rule>

    <handle-rule typename="framebuffer" type="uint32_t">
      <match param-expression="((readF|drawF|f)ramebuffer(s|)|fbos)"/>
    </handle-rule>

    <handle-rule typename="texture" type="uint32_t">
      <match param-expression="texture(s|)"/>
    </handle-rule>

    <handle-rule typename="renderbuffer" type="uint32_t">
      <match param-expression="renderbuffer(s|)"/>
    </handle-rule>

    <handle-rule typename="sampler" type="uint32_t">
      <match param-expression="sampler(s|)"/>
    </handle-rule>

    <handle-rule typename="pipeline" type="uint32_t">
      <match param-expression="pipeline(s|)"/>
    </handle-rule>

    <handle-rule typename="vertex_array" type="uint32_t">
      <match param-expression="array(s|)" command-expression=".*VertexArray.*"/>
      <match param-expression="vaobj"/>
    </handle-rule>

    <handle-rule typename="command_list" type="uint32_t">
      <match param-expression="list(s|)"/>
    </handle-rule>

    <handle-rule typename="state" type="uint32_t">
      <match param-expression="state(s|)"/>
    </handle-rule>

    <handle-rule typename="path" type="uint32_t">
      <match param-expression="(path(s|)|firstPathName|pathBase|resultPath|srcPath)"/>
      <match enable-return="true" command-expression="glGenPathsNV"/>
    </handle-rule>

    <handle-rule typename="transform_feedback" type="uint32_t">
      <match command-expression=".*TransformFeedback.*" param-expression="(id(s|)|xfb)"/>
    </handle-rule>

  </rules>
</mygl-generator>